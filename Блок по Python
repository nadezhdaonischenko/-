Блок 2: Python
Задание 1: Изоморфизмы
Реализовать функцию (или тело функции), которая проверяет на изоморфность два слова. Пояснение: строки s и t называются изоморфными, если все вхождения каждого символа строки s можно последовательно заменить другим символом и получить строку t. Порядок символов при этом должен сохраняться, а замена — быть уникальной. Так, два разных символа строки s нельзя заменить одним и тем же символом из строки t, а вот одинаковые символы в строке s должны заменяться одним и тем же символом.
# Пример:
s = 'paper' 
t = 'title' 
print(is_isomorphic(s, t))
# Вывод: 
True
Оценить оптимальность решения по времени и памяти и прикрепить текст кода.

print(f'Введите первое слово:')
s=input()
print(f'Введите второе слово:')
t=input()

def is_isomorphic(s, t):
  if len(s)!=len(t):    # если свова изначально не равны по количеству букв, дальше нет смысла проверять
    return False

  dict_st = {}    # создадим словари для пар букв
  dict_ts = {}

  for s_char, t_char in zip(s, t):
    if (s_char in dict_st and dict_st[s_char]!=t_char) or (t_char in dict_ts and dict_ts[t_char]!=s_char):  # проверяем не совпадают ли буквы
        return False
    else:
      dict_st[s_char]=t_char
      dict_ts[t_char]=s_char
  return True

print(is_isomorphic(s, t))

Оценка оптимальность решения по времени - O(n) и памяти O(k).

Задание 2: Натуральная последовательность
Реализовать функцию (или тело функции), которая находит единственное отсутствующее число из последовательности натуральных чисел 1,2,…,n.
# Пример:
nums = [1, 2, 3, 4, 5, 6, 8, 9, 10, 11]
print(missing_number(nums))
# Вывод: 
7
Оценить оптимальность решения по времени и памяти и прикрепить текст кода.




Задание 3: Факторизация
Реализовать функцию (или тело функции), которая при введении натурального числа n разбивает его на простые множители (представить его в виде простых чисел).
# Пример:
n = 56
print(prime_factors(n))
# Вывод:
[2, 2, 2, 7]
Оценить оптимальность решения по времени и памяти и прикрепить текст кода.
