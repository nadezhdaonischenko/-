Блок 2: Python
Задание 1: Изоморфизмы
Реализовать функцию (или тело функции), которая проверяет на изоморфность два слова. Пояснение: строки s и t называются изоморфными, если все вхождения каждого символа строки s можно последовательно заменить другим символом и получить строку t. Порядок символов при этом должен сохраняться, а замена — быть уникальной. Так, два разных символа строки s нельзя заменить одним и тем же символом из строки t, а вот одинаковые символы в строке s должны заменяться одним и тем же символом.
# Пример:
s = 'paper' 
t = 'title' 
print(is_isomorphic(s, t))
# Вывод: 
True
Оценить оптимальность решения по времени и памяти и прикрепить текст кода.

print('Введите первое слово:')
s=input()
print('Введите второе слово:')
t=input()

def is_isomorphic(s, t):
  if len(s)!=len(t):    # если свова изначально не равны по количеству букв, дальше нет смысла проверять
    return False

  dict_st = {}    # создадим словари для пар букв
  dict_ts = {}

  for s_char, t_char in zip(s, t):
    if (s_char in dict_st and dict_st[s_char]!=t_char) or (t_char in dict_ts and dict_ts[t_char]!=s_char):  # проверяем не совпадают ли буквы
        return False
    else:
      dict_st[s_char]=t_char
      dict_ts[t_char]=s_char
  return True

print(is_isomorphic(s, t))

Оценка оптимальность решения по времени - O(n) и памяти O(k).

Задание 2: Натуральная последовательность
Реализовать функцию (или тело функции), которая находит единственное отсутствующее число из последовательности натуральных чисел 1,2,…,n.
# Пример:
nums = [1, 2, 3, 4, 5, 6, 8, 9, 10, 11]
print(missing_number(nums))
# Вывод: 
7
Оценить оптимальность решения по времени и памяти и прикрепить текст кода.

print('Введите числа через запятую:')
nums = [int(i) for i in int(input()).split(",")]

def missing_number(nums):
  n = len(nums)+1
  sum_n = n(n+1)/2
  sum_num = sum(nums)
  return sum(n)-sum(nums)

print(missing_number(nums))

Оценка оптимальность решения по времени - O(n) и памяти O(1).

Задание 3: Факторизация
Реализовать функцию (или тело функции), которая при введении натурального числа n разбивает его на простые множители (представить его в виде простых чисел).
# Пример:
n = 56
print(prime_factors(n))
# Вывод:
[2, 2, 2, 7]
Оценить оптимальность решения по времени и памяти и прикрепить текст кода.

print('Введите число:')
n = int(input())

def prime_factors(n):
  min_del = 2   # Наименьшее чростое число больше 1
  sp_del=[]
  while min_del*min_del <= n:
    if n%min_del==0:
      sp_del.append(min_del)
      n=n/min_del
    else:
      min_del+=1
  if n>1:
    sp_del.append(int(n))
  return *sp_del

print(prime_factors(n))

      
